generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider          = "postgresql"
  url               = env("DATABASE_URL")
  shadowDatabaseUrl = env("SHADOW_DATABASE_URL")
}

/**
 * ===========================
 * Enums
 * ===========================
 */
enum Role {
  OWNER
  ADMIN
  TESOURARIA
  SECRETARIA
  CONTADOR
  LEITURA
}

enum DocType {
  PAYABLE // A Pagar
  RECEIVABLE // A Receber
}

enum CostCenterType {
  MINISTRY
  EVENT
  GROUP
}

enum DocStatus {
  OPEN
  PAID
  OVERDUE // opcionalmente calculado; aqui persistido
}

enum MemberStatus {
  ACTIVE
  INACTIVE
  VISITOR
}

enum SupplierType {
  PF // Pessoa Física
  PJ // Pessoa Jurídica
}

enum CategoryScope {
  FINANCE
  SUPPLIER
  ASSET
}

enum FinanceKind {
  INCOME
  EXPENSE
}

enum AssetStatus {
  ACTIVE
  MAINTENANCE
  DISPOSED
}

enum InviteStatus {
  PENDING
  ACCEPTED
  REVOKED
  EXPIRED
}

enum AuditAction {
  CREATE
  UPDATE
  DELETE
}

/**
 * ===== Billing (planos/assinaturas) =====
 */
enum PlanInterval {
  MONTHLY
  YEARLY
}

enum SubscriptionStatus {
  INCOMPLETE
  TRIALING
  ACTIVE
  PAST_DUE
  CANCELED
}

enum BillingProvider {
  STRIPE
  PAGARME
  MERCADO_PAGO
  ASAAS
}

/**
 * =========================================
 * Núcleo multi-tenant: Organization & Membership
 * =========================================
 */
model Organization {
  id        String   @id @default(uuid()) @db.Uuid
  name      String
  taxId     String? // CNPJ/identificação opcional
  active    Boolean  @default(true)
  createdBy String?  @db.Uuid // auth.users.id (quem criou a organização)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relações
  memberships      Membership[]
  members          Member[]
  suppliers        Supplier[]
  costCenters      CostCenter[]
  categories       Category[]
  documents        Document[]
  assets           Asset[]
  invites          OrgInvite[]
  audits           AuditLog[]
  ministries       Ministry[]
  memberMinistries MemberMinistry[]

  subscriptions Subscription[] // << novo: assinaturas (uma org pode ter várias ao longo do tempo)

  @@index([active])
  @@map("organizations")
}

model Membership {
  id        String   @id @default(uuid()) @db.Uuid
  orgId     String   @db.Uuid
  userId    String   @db.Uuid // Supabase auth.users.id (UUID)
  role      Role
  createdAt DateTime @default(now())

  org Organization @relation(fields: [orgId], references: [id], onDelete: Cascade)

  // Se mapear 'auth.users', pode declarar a relação aqui:
  // user AuthUser @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, orgId])
  @@index([orgId, role])
  @@map("memberships")
}

// (Opcional) Se usar Prisma Multi-Schema para enxergar auth.users:
/**
 * model AuthUser {
 * id        String    @id @db.Uuid
 * email     String?
 * createdAt DateTime? @map("created_at")
 * @@schema("auth")
 * @@map("users")
 * }
 */

/**
 * =========================================
 * Cadastros: Members, Suppliers, Cost Centers, Categories
 * =========================================
 */
model Member {
  id         String       @id @default(uuid()) @db.Uuid
  orgId      String       @db.Uuid
  fullName   String
  birthDate  DateTime?
  email      String?
  phone      String?
  address    String?
  ministries String[] // lista simples; pode virar relação no futuro
  status     MemberStatus @default(ACTIVE)
  createdAt  DateTime     @default(now())
  updatedAt  DateTime     @updatedAt

  //Relações
  memberMinistries MemberMinistry[]

  org       Organization @relation(fields: [orgId], references: [id], onDelete: Cascade)
  documents Document[]   @relation("DocMember")

  @@index([orgId, status])
  @@index([orgId, fullName])
  @@map("members")
}

model Supplier {
  id        String       @id @default(uuid()) @db.Uuid
  orgId     String       @db.Uuid
  type      SupplierType
  name      String
  email     String?
  phone     String?
  taxId     String? // CPF/CNPJ (mascarar/validar na app)
  bankInfo  String? // dados bancários (mínimos; cuidado LGPD)
  address   String?
  category  String? // livre/curta; para filtros simples
  status    Boolean      @default(true) // ativo/inativo
  createdAt DateTime     @default(now())
  updatedAt DateTime     @updatedAt

  org       Organization @relation(fields: [orgId], references: [id], onDelete: Cascade)
  documents Document[]   @relation("DocSupplier")

  @@index([orgId, status])
  @@index([orgId, name])
  @@map("suppliers")
}

model CostCenter {
  id    String @id @default(uuid()) @db.Uuid
  orgId String @db.Uuid

  type CostCenterType @default(GROUP)

  // Nome livre para não-ministry; quando MINISTRY será sincronizado com Ministry.name (via lógica/trigger)
  name String

  // Relação 1:1 (opcional) — UNIQUE garante um CC por Ministry
  ministryId String?   @unique(map: "uq_cost_centers_ministryId") @db.Uuid
  ministry   Ministry? @relation(fields: [ministryId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  org       Organization @relation(fields: [orgId], references: [id], onDelete: Cascade)
  documents Document[]

  // Unicidade de nome por org para não duplicar nomes de CC
  @@unique([orgId, name])
  @@index([orgId])
  @@map("cost_centers")
}

model Category {
  id          String        @id @default(uuid()) @db.Uuid
  orgId       String        @db.Uuid
  name        String
  scope       CategoryScope // FINANCE | SUPPLIER | ASSET
  financeKind FinanceKind? // INCOME/EXPENSE (quando scope=FINANCE)
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt

  org       Organization  @relation(fields: [orgId], references: [id], onDelete: Cascade)
  documents Document[] // quando scope=FINANCE
  assets    Asset[] // quando scope=ASSET

  @@unique([orgId, scope, name])
  @@index([orgId, scope])
  @@map("categories")
}

/**
 * =========================================
 * Financeiro: Documents (AP/AR)
 * =========================================
 */
model Document {
  id           String    @id @default(uuid()) @db.Uuid
  orgId        String    @db.Uuid
  type         DocType
  description  String
  amount       Decimal   @db.Decimal(14, 2)
  categoryId   String?   @db.Uuid
  costCenterId String?   @db.Uuid
  supplierId   String?   @db.Uuid // A Pagar
  memberId     String?   @db.Uuid // A Receber
  issueDate    DateTime
  dueDate      DateTime
  status       DocStatus @default(OPEN)
  paymentDate  DateTime?
  notes        String?
  createdBy    String?   @db.Uuid // auth.users.id (quem criou)
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  org        Organization @relation(fields: [orgId], references: [id], onDelete: Cascade)
  category   Category?    @relation(fields: [categoryId], references: [id])
  costCenter CostCenter?  @relation(fields: [costCenterId], references: [id])
  supplier   Supplier?    @relation("DocSupplier", fields: [supplierId], references: [id])
  member     Member?      @relation("DocMember", fields: [memberId], references: [id])

  // Observação: regra "supplierId XOR memberId" deve ser validada na aplicação (ou via trigger SQL).

  @@index([orgId, type])
  @@index([orgId, status])
  @@index([orgId, dueDate])
  @@index([orgId, paymentDate])
  @@index([orgId, categoryId])
  @@index([orgId, costCenterId])
  @@map("documents")
}

/**
 * =========================================
 * Patrimônio (básico)
 * =========================================
 */
model Asset {
  id             String      @id @default(uuid()) @db.Uuid
  orgId          String      @db.Uuid
  description    String
  categoryId     String?     @db.Uuid
  status         AssetStatus @default(ACTIVE)
  location       String? // local/ministerio
  responsible    String? // nome textual (pode virar FK para Member)
  acquisitionAt  DateTime?
  acquisitionVal Decimal?    @db.Decimal(14, 2)
  notes          String?
  createdAt      DateTime    @default(now())
  updatedAt      DateTime    @updatedAt

  org      Organization @relation(fields: [orgId], references: [id], onDelete: Cascade)
  category Category?    @relation(fields: [categoryId], references: [id])

  @@index([orgId, status])
  @@index([orgId, categoryId])
  @@map("assets")
}

/**
 * =========================================
 * Organização: Convites & Auditoria
 * =========================================
 */
model OrgInvite {
  id        String       @id @default(uuid()) @db.Uuid
  orgId     String       @db.Uuid
  email     String
  role      Role
  token     String       @unique
  status    InviteStatus @default(PENDING)
  expiresAt DateTime
  invitedBy String?      @db.Uuid // auth.users.id
  createdAt DateTime     @default(now())

  org Organization @relation(fields: [orgId], references: [id], onDelete: Cascade)

  @@index([orgId, status, expiresAt])
  @@map("org_invites")
}

model AuditLog {
  id        String      @id @default(uuid()) @db.Uuid
  orgId     String      @db.Uuid
  userId    String?     @db.Uuid // auth.users.id
  table     String
  rowId     String
  action    AuditAction
  at        DateTime    @default(now())
  oldValues Json?
  newValues Json?

  org Organization @relation(fields: [orgId], references: [id], onDelete: Cascade)

  @@index([orgId, table, action, at])
  @@map("audit_log")
}

/**
 * =========================================
 * Billing: Planos & Assinaturas (SaaS)
 * =========================================
 */
model Plan {
  id              String           @id @default(uuid()) @db.Uuid
  name            String
  interval        PlanInterval
  amount          Decimal          @db.Decimal(10, 2) // valor por período
  currency        String           @default("BRL")
  trialDays       Int?
  isActive        Boolean          @default(true)
  provider        BillingProvider?
  providerPriceId String? // ID do preço/plano no provedor (ex.: Stripe Price ID)
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt

  features      PlanFeature[]
  subscriptions Subscription[]

  @@unique([name, interval]) // evita duplicidade de plano por periodicidade
  @@map("plans")
}

model PlanFeature {
  id       String  @id @default(uuid()) @db.Uuid
  planId   String  @db.Uuid
  key      String // ex.: ASSETS_ENABLED, COST_CENTER_LIMIT, etc.
  label    String // rótulo amigável para exibir na landing
  included Boolean @default(true)
  limitInt Int? // limite numérico quando aplicável (ex.: qtd. centros de custo)

  plan Plan @relation(fields: [planId], references: [id], onDelete: Cascade)

  @@unique([planId, key])
  @@index([planId])
  @@map("plan_features")
}

model Subscription {
  id                     String             @id @default(uuid()) @db.Uuid
  orgId                  String             @db.Uuid
  planId                 String             @db.Uuid
  status                 SubscriptionStatus @default(INCOMPLETE)
  provider               BillingProvider?
  providerCustomerId     String?
  providerSubscriptionId String?            @unique
  seats                  Int?               @default(1)
  currentPeriodStart     DateTime?
  currentPeriodEnd       DateTime?
  cancelAt               DateTime?
  trialEndsAt            DateTime?
  createdAt              DateTime           @default(now())
  updatedAt              DateTime           @updatedAt

  org  Organization @relation(fields: [orgId], references: [id], onDelete: Cascade)
  plan Plan         @relation(fields: [planId], references: [id])

  @@index([orgId, status])
  @@index([orgId, currentPeriodEnd])
  @@index([planId])
  @@map("subscriptions")
}

model Ministry {
  id          String   @id @default(uuid()) @db.Uuid
  orgId       String   @db.Uuid
  name        String
  description String?
  active      Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  org     Organization     @relation(fields: [orgId], references: [id], onDelete: Cascade)
  members MemberMinistry[]

  // NEW: back-relation 1:1 com CostCenter
  costCenter CostCenter?

  @@unique([orgId, name])
  @@index([orgId, active])
  @@map("ministries")
}

model MemberMinistry {
  id         String    @id @default(uuid()) @db.Uuid
  orgId      String    @db.Uuid
  memberId   String    @db.Uuid
  ministryId String    @db.Uuid
  role       String? // pode evoluir para enum depois (LEADER/ASSISTANT/MEMBER)
  sinceDate  DateTime?
  untilDate  DateTime?
  notes      String?
  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt

  org      Organization @relation(fields: [orgId], references: [id], onDelete: Cascade)
  member   Member       @relation(fields: [memberId], references: [id], onDelete: Cascade)
  ministry Ministry     @relation(fields: [ministryId], references: [id], onDelete: Cascade)

  @@index([orgId, ministryId])
  @@index([orgId, memberId])
  @@map("member_ministries")
}
