generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider          = "postgresql"
  url               = env("DATABASE_URL")
  shadowDatabaseUrl = env("SHADOW_DATABASE_URL")
}

/**
 * =========================================
 * Núcleo multi-tenant: Organization & Membership
 * =========================================
 */
model Organization {
  id        String   @id @default(uuid()) @db.Uuid
  name      String
  taxId     String?
  active    Boolean  @default(true)
  createdBy String?  @db.Uuid
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relações
  assets           Asset[]
  audits           AuditLog[]
  categories       Category[]
  costCenters      CostCenter[]
  documents        Document[]
  memberMinistries MemberMinistry[]
  members          Member[]
  memberships      Membership[]
  ministries       Ministry[]
  invites          OrgInvite[]
  subscriptions    Subscription[]
  suppliers        Supplier[]

  @@index([active])
  @@map("organizations")
}

model Membership {
  id        String   @id @default(uuid()) @db.Uuid
  orgId     String   @db.Uuid
  userId    String   @db.Uuid
  role      Role
  createdAt DateTime @default(now())

  org Organization @relation(fields: [orgId], references: [id], onDelete: Cascade)

  @@unique([userId, orgId])
  @@index([orgId, role])
  @@map("memberships")
}

/**
 * =========================================
 * Cadastros: Members, Suppliers, Cost Centers, Categories
 * =========================================
 */
model Member {
  id         String       @id @default(uuid()) @db.Uuid
  orgId      String       @db.Uuid
  fullName   String
  birthDate  DateTime?
  email      String?
  phone      String?
  address    String?
  ministries String[]
  status     MemberStatus @default(ACTIVE)
  createdAt  DateTime     @default(now())
  updatedAt  DateTime     @updatedAt

  // Relações
  documents        Document[]       @relation("DocMember")
  memberMinistries MemberMinistry[]
  org              Organization     @relation(fields: [orgId], references: [id], onDelete: Cascade)

  @@index([orgId, status])
  @@index([orgId, fullName])
  @@map("members")
}

model Supplier {
  id        String       @id @default(uuid()) @db.Uuid
  orgId     String       @db.Uuid
  type      SupplierType
  name      String
  email     String?
  phone     String?
  taxId     String? // CPF/CNPJ sem máscara
  bankInfo  String?
  address   String?
  category  String?
  status    Boolean      @default(true)
  createdAt DateTime     @default(now())
  updatedAt DateTime     @updatedAt

  // Relações
  documents Document[]   @relation("DocSupplier")
  org       Organization @relation(fields: [orgId], references: [id], onDelete: Cascade)
  // (Opcional) se quiser o lado inverso em Asset, adicione: assets Asset[]
  Asset     Asset[]

  @@index([orgId, status])
  @@index([orgId, name])
  @@map("suppliers")
}

model CostCenter {
  id         String         @id @default(uuid()) @db.Uuid
  orgId      String         @db.Uuid
  name       String
  createdAt  DateTime       @default(now())
  updatedAt  DateTime       @updatedAt
  ministryId String?        @unique(map: "uq_cost_centers_ministryId") @db.Uuid
  type       CostCenterType @default(GROUP)

  // Relações
  ministry  Ministry?    @relation(fields: [ministryId], references: [id])
  org       Organization @relation(fields: [orgId], references: [id], onDelete: Cascade)
  documents Document[]

  @@unique([orgId, name])
  @@index([orgId])
  @@map("cost_centers")
}

model Category {
  id          String        @id @default(uuid()) @db.Uuid
  orgId       String        @db.Uuid
  name        String
  scope       CategoryScope // FINANCE | SUPPLIER | ASSET
  financeKind FinanceKind? // INCOME/EXPENSE quando scope=FINANCE
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt

  // Relações
  assets    Asset[]
  org       Organization @relation(fields: [orgId], references: [id], onDelete: Cascade)
  documents Document[]

  @@unique([orgId, scope, name])
  @@index([orgId, scope])
  @@map("categories")
}

/**
 * =========================================
 * Financeiro: Documents (AP/AR)
 * =========================================
 */
model Document {
  id           String    @id @default(uuid()) @db.Uuid
  orgId        String    @db.Uuid
  type         DocType
  description  String
  amount       Decimal   @db.Decimal(14, 2)
  categoryId   String?   @db.Uuid
  costCenterId String?   @db.Uuid
  supplierId   String?   @db.Uuid // A Pagar
  memberId     String?   @db.Uuid // A Receber
  issueDate    DateTime
  dueDate      DateTime
  status       DocStatus @default(OPEN)
  paymentDate  DateTime?
  notes        String?
  createdBy    String?   @db.Uuid
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  // Relações
  category   Category?    @relation(fields: [categoryId], references: [id])
  costCenter CostCenter?  @relation(fields: [costCenterId], references: [id])
  supplier   Supplier?    @relation("DocSupplier", fields: [supplierId], references: [id])
  member     Member?      @relation("DocMember", fields: [memberId], references: [id])
  org        Organization @relation(fields: [orgId], references: [id], onDelete: Cascade)

  @@index([orgId, type])
  @@index([orgId, status])
  @@index([orgId, dueDate])
  @@index([orgId, paymentDate])
  @@index([orgId, categoryId])
  @@index([orgId, costCenterId])
  @@map("documents")
}

/**
 * =========================================
 * Patrimônio
 * =========================================
 */
model Asset {
  id             String      @id @default(uuid()) @db.Uuid
  orgId          String      @db.Uuid
  name           String
  code           String? // número de patrimônio (gerado por trigger se null)
  description    String? // agora opcional, compatível com o form
  categoryId     String?     @db.Uuid
  supplierId     String?     @db.Uuid
  status         AssetStatus @default(IN_USE)
  location       String?
  responsible    String?
  acquisitionAt  DateTime?
  acquisitionVal Decimal?    @db.Decimal(14, 2)
  notes          String?
  createdAt      DateTime    @default(now())
  updatedAt      DateTime    @updatedAt

  // Relações
  org      Organization @relation(fields: [orgId], references: [id], onDelete: Cascade)
  category Category?    @relation(fields: [categoryId], references: [id])
  supplier Supplier?    @relation(fields: [supplierId], references: [id], onDelete: SetNull)

  @@unique([orgId, code]) // unicidade do patrimônio por organização (permite múltiplos NULL)
  @@index([orgId, status])
  @@index([orgId, categoryId])
  @@index([orgId, supplierId])
  @@map("assets")
}

/**
 * =========================================
 * Organização: Convites & Auditoria
 * =========================================
 */
model OrgInvite {
  id        String       @id @default(uuid()) @db.Uuid
  orgId     String       @db.Uuid
  email     String
  role      Role
  token     String       @unique
  status    InviteStatus @default(PENDING)
  expiresAt DateTime
  invitedBy String?      @db.Uuid
  createdAt DateTime     @default(now())

  org Organization @relation(fields: [orgId], references: [id], onDelete: Cascade)

  @@index([orgId, status, expiresAt])
  @@map("org_invites")
}

model AuditLog {
  id        String      @id @default(uuid()) @db.Uuid
  orgId     String      @db.Uuid
  userId    String?     @db.Uuid
  table     String
  rowId     String
  action    AuditAction
  at        DateTime    @default(now())
  oldValues Json?
  newValues Json?

  org Organization @relation(fields: [orgId], references: [id], onDelete: Cascade)

  @@index([orgId, table, action, at])
  @@map("audit_log")
}

/**
 * =========================================
 * Billing: Planos & Assinaturas (SaaS)
 * =========================================
 */
model Plan {
  id              String           @id @default(uuid()) @db.Uuid
  name            String
  interval        PlanInterval
  amount          Decimal          @db.Decimal(10, 2)
  currency        String           @default("BRL")
  trialDays       Int?
  isActive        Boolean          @default(true)
  provider        BillingProvider?
  providerPriceId String?
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt

  features      PlanFeature[]
  subscriptions Subscription[]

  @@unique([name, interval])
  @@map("plans")
}

model PlanFeature {
  id       String  @id @default(uuid()) @db.Uuid
  planId   String  @db.Uuid
  key      String
  label    String
  included Boolean @default(true)
  limitInt Int?

  plan Plan @relation(fields: [planId], references: [id], onDelete: Cascade)

  @@unique([planId, key])
  @@index([planId])
  @@map("plan_features")
}

model Subscription {
  id                     String             @id @default(uuid()) @db.Uuid
  orgId                  String             @db.Uuid
  planId                 String             @db.Uuid
  status                 SubscriptionStatus @default(INCOMPLETE)
  provider               BillingProvider?
  providerCustomerId     String?
  providerSubscriptionId String?            @unique
  seats                  Int?               @default(1)
  currentPeriodStart     DateTime?
  currentPeriodEnd       DateTime?
  cancelAt               DateTime?
  trialEndsAt            DateTime?
  createdAt              DateTime           @default(now())
  updatedAt              DateTime           @updatedAt

  org  Organization @relation(fields: [orgId], references: [id], onDelete: Cascade)
  plan Plan         @relation(fields: [planId], references: [id])

  @@index([orgId, status])
  @@index([orgId, currentPeriodEnd])
  @@index([planId])
  @@map("subscriptions")
}

model Ministry {
  id          String   @id @default(uuid()) @db.Uuid
  orgId       String   @db.Uuid
  name        String
  description String?
  active      Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relações
  costCenter CostCenter?
  members    MemberMinistry[]
  org        Organization     @relation(fields: [orgId], references: [id], onDelete: Cascade)

  @@unique([orgId, name])
  @@index([orgId, active])
  @@map("ministries")
}

model MemberMinistry {
  id         String    @id @default(uuid()) @db.Uuid
  orgId      String    @db.Uuid
  memberId   String    @db.Uuid
  ministryId String    @db.Uuid
  role       String?
  sinceDate  DateTime?
  untilDate  DateTime?
  notes      String?
  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt

  member   Member       @relation(fields: [memberId], references: [id], onDelete: Cascade)
  ministry Ministry     @relation(fields: [ministryId], references: [id], onDelete: Cascade)
  org      Organization @relation(fields: [orgId], references: [id], onDelete: Cascade)

  @@index([orgId, ministryId])
  @@index([orgId, memberId])
  @@map("member_ministries")
}

/**
 * ===========================
 * Enums
 * ===========================
 */
enum Role {
  OWNER
  ADMIN
  TESOURARIA
  SECRETARIA
  CONTADOR
  LEITURA
}

enum DocType {
  PAYABLE
  RECEIVABLE
}

enum CostCenterType {
  MINISTRY
  EVENT
  GROUP
}

enum DocStatus {
  OPEN
  PAID
  OVERDUE
}

enum MemberStatus {
  ACTIVE
  INACTIVE
  VISITOR
}

enum SupplierType {
  PF
  PJ
}

enum CategoryScope {
  FINANCE
  SUPPLIER
  ASSET
}

enum FinanceKind {
  INCOME
  EXPENSE
}

/**
 * Substitui o enum antigo de AssetStatus.
 * Use estes valores no app (faça o mapeamento se precisar).
 */
enum AssetStatus {
  IN_USE
  IN_STORAGE
  IN_MAINTENANCE
  DISPOSED
}

enum InviteStatus {
  PENDING
  ACCEPTED
  REVOKED
  EXPIRED
}

enum AuditAction {
  CREATE
  UPDATE
  DELETE
}

/**
 * ===== Billing (planos/assinaturas) =====
 */
enum PlanInterval {
  MONTHLY
  YEARLY
}

enum SubscriptionStatus {
  INCOMPLETE
  TRIALING
  ACTIVE
  PAST_DUE
  CANCELED
}

enum BillingProvider {
  STRIPE
  PAGARME
  MERCADO_PAGO
  ASAAS
}
